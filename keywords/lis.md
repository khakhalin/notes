# Longest Increasing Subsequence

#algo

See also: [[algos]]

**Simple solution** has time complexity of O(nÂ²). Assume that for every point we processed, we'll remember the longest sequence that ended at it (probably a reference to the previous point in the sequence, and the total length of a sequence). Now, go through all points left to right. For each new point Xi, go through all points to the left from it (j in 0:i), and of all points that are Xj<Xi, that is, for all sequnces that Xi can extend. Of them pick the one of highest length. Store this info for Xi; if necessary, update the current estimation of the longest found sequence, and the reference to it (the value of i). Do it for all points. At the end, you'll know the last element of the longest sequence, and for each element Xi in this sequence we'll have a pointer at the previous element of the sequence Xj, so we can reconstruct the full winner sequence and return it.

**Fancy solution** is O(n log n), and relies on the fact that looking for the longest incomplete sequence among all sequences that end at a small enough value (Xj < Xi) is the same as looking for a small enough value (highest Xj that is still < Xi) among all longest incomplete sequences. The benefit here is that in these scenario, the "incomplete sequences" can be sorted in order (by the value of their last element), allowing us to perform binary search (log N steps) instead of a complete look-through (N steps), and then extending this one sequence only. Resulting in a final O(n log n) complexity. And what's more, we don't even have to artificially sort them, as they are "naturally" constructed as a sorted sequence! If it's not intuitive yet, just read along.

Let's start with that: why looking for a highest Xj that is < Xi, and then extending it, does the trick? Consider this: many points in `[X]` are just not useful, and will never be a part of the longest sequence. Sure, as you go left to right, if a new point is high, it may be added to a growing sequence. If a point is low, it may start a new promising sequence, or improve a sequence that was already going. But each improvement renders some previously used points obsolete. For example, in a sequence `0,4,2` the point 4 will never be a part of a sequence, as any sequence that could contain 4 (such as `0,4,5` for example), can also contain 2 (as in `0,2,5`). Yet 2 is strictly better than 4, as if the next point in the sequence happenes to be 3, it can extend `0,2`, but it cannot extend `0,4`. So by the time we observed `0,4,2`, we know that `0,2` is the best length-2 sequence currently available, while `0` is the best available length-1 sequence (it can get useful in the future if we stumble upon a subsequence `1,2,3` that can extend `0`), and there is no length-3 sequence.

In other words, at any point, it is enough if we keep track of the **best observed sequence of length k**, for every available k. Indeed, two sequences length k would be both uniquely "worthy" only if they ended at different values (coz otherwise they are fully interchangeable). But then one of them ends at a higher value, and this value can extend the other, forming a sequence length k+1. Which means that the original sequence length-k with a higher final value was a strictly worse solution, and is not worth remembering. For each k, at every moment, we only need to remember the sequence lengh-k that ends at the lowest possible value.

But this means that finding the best sequence to extend, for each new Xi, is really easy, as by the nature of the data, they are all ordered by the value of their last elements! We don't need to even sort them, they form a natural "wedge": every longer sentence "naturally" ends at a higher value. And so we can use binary search! We can just binary-search through all sequences, looking for a highest ending value that is still below Xi. This would be the best sequence (length k) to extend with Xi, forming a new sequence length k+1. This new sequence length k+1 would be better (or at least not worse) than the old  sequence length k+1, as the old k+1 sequence clearly ended at something higher than Xi (just by virtue of not being found at the previous step). So we overwrite it, and then keep doing that until the end of X, at which point the longest sequence is the winning sequence. 

In practice, of course, we don't have to remember entire sequences, but instead we can remember the last ement of each sequence, and also, for each element, remember references from it to the previous element. Once everything is analyzed, we can reconstruct the best sequence by jumping through the references, from the end to the beginning. Meaning that the data structures we need include:
* A list of last elements, where `last[j]` gives the last element of a sequence length j+1. This may be up to length N for a worst case scenario (motononous decrease), but will probably be smaller for most data.
* A list of "backwards references" to the "best previous element to extend", also length N.

# References:
* https://en.wikipedia.org/wiki/Longest_increasing_subsequence
* https://www.geeksforgeeks.org/construction-of-longest-monotonically-increasing-subsequence-n-log-n/
* http://manzzup.blogspot.com/2015/08/explained-finding-longest-increasing.html