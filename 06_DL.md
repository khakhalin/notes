# Deep learning

**Topics that live in separate documents:**
* [[transformers]]

# Backpropagation
Essentially a chain diff rule, for cost function J by weights w.

Consider a network of several layers (full = dense = all to all), eventually all convering on one output element (just because it's easier to describe it for one output element, but the math is essentially the same if you have many). MSE loss: J=(a0-y)Â², where a0 = out = h(z) = h(âˆ‘ w10_i a1_i) = dot product of of prev (1st) layer activations with weights from 1 to 0. (I'll be numbering layers backwards, starting from 0 for the output layer)

$a^0 = h (\sum w^{10}_ i a^1_i )$

To change one of the weights w10_i, we need to know âˆ‚J/âˆ‚w10_i . For this one weight we have: âˆ‚J/âˆ‚w10_i = âˆ‚J/âˆ‚a0 âˆ‚a0/âˆ‚z âˆ‚z/âˆ‚w10_i = 2(a-y) h'(z) a1_i,
because âˆ‚J/âˆ‚a0 = 2(a0-y),
âˆ‚a0/âˆ‚z = âˆ‚h(z)/âˆ‚z = h'(z), and
âˆ‚z/âˆ‚w10_i = a1_i. That is, activation a1_i arriving from the layer 1, that gets multiplied by w10_i.

$\displaystyle \frac{âˆ‚J}{âˆ‚w^{10}_ {i}} = \frac{âˆ‚J}{âˆ‚a^0} \frac{âˆ‚a^0}{âˆ‚z^0} \frac{âˆ‚z^0}{âˆ‚w^{10}_ i} = 2(a^0-y) h'(z^0) a^1_i = Îµ^0 a^1_i$

So it is actually reminiscent of the Hebbian rule: if the output needs to be changed (the (a0-y) is large), and the activity of some unit a1_i is large (it deserves of listening to), and changing the input can actually change something (h'(z) is reasonably large), then this weight (w10_i) matters, and needs to be changed. In practice, if we want to reduce J, the weight it needs to be reduced, so we go against the gradient.

We get a similar formula for bias, as for all layers except the lsat one it's always h(wâˆ™a+b) and not just h(wâˆ™a), except that we just get 1 instead of a1 in the formula, as âˆ‚z/âˆ‚b = 1. So if we had bias at this 0th layer, we'd have âˆ‚J/âˆ‚b = Îµ0.

Now we can go deeper, to the yet-previous layer 2â†’1, with weights w21_j.
No need to sum yet, as w21_j only affects one element in the 1st layer: a1_i:
Again, we have:
âˆ‚J/âˆ‚w21_j = âˆ‚J/âˆ‚a1_i âˆ‚a1_i/âˆ‚w21_j.
âˆ‚J/âˆ‚a1_i can be calculated as above = 2(a0-y) h'(z0) w10_i,
while âˆ‚a1_i/âˆ‚w2_j = âˆ‚a1_i/âˆ‚z1_i âˆ‚z1_i/âˆ‚w2_j = h'(z1_i) a2_j (activation a2_j from yet prev layer).
So the full expression: âˆ‚J/âˆ‚w21_j = 2(a-y) h'(z) w10_i h'(z1_i) a2_j.

$\displaystyle \frac{âˆ‚J}{âˆ‚w^{21}_ j} = \frac{âˆ‚J}{âˆ‚a^1_i} \frac{âˆ‚a^1_i}{âˆ‚w^{21}_ j} = 2(a^0-y)h'(z^0)w^{10}_ i h'(z^1_ i) a^2_ j = Îµ^0 w^{10}_ i h'(z^1_ i) a^2_ j = Îµ^1_i a^2_j$

where $w^{21}_ j$ should actually read $w^{21}_ {jâ†’i}$ , or $w^{21}_ {ij}$, as it is projecting from element j in layer 2 to element i in layer 1.

And similar to what we had before, $\displaystyle \frac{âˆ‚J}{âˆ‚b^1_i} = Îµ^1_i$.

This part about $Îµ^1_i = Îµ^0 w^{10}_ i h'(z^1_ i)$ is why this process is called **backpropagation**: the error at layer 2â†’1 is obtained from 

Now consider layer 3â†’2. Again chain rule, but now while link w32_k coming from a neuron a3_k in the 3d layer affects only one neuron a2_j in the 2nd layer, this activity in turn affects all neurons a1_i in the first layer. And then each of them gathers on our single output. So index i for 1â†’0 is no longer fixed, but we have to run a sum for it:

âˆ‚J/âˆ‚w32_k = âˆ‘_i âˆ‚J/âˆ‚a1_i âˆ‚a1_i/âˆ‚w32_k = 
2(a0-y) h'(z0) âˆ‘_i w10_i âˆ‚a1_i/âˆ‚w32_k = 
2(a0-y) h'(z0) âˆ‘_i w10_i h'(z1_i) w21_j âˆ‚a2_j/âˆ‚w32_k = 
2(a0-y) h'(z0) âˆ‘_i w10_i h'(z1_i) w21_j h'(z2_j) a3_k.

$\displaystyle \frac{âˆ‚J}{âˆ‚w^{32}_ k} = \sum_i \frac{âˆ‚J}{âˆ‚a^1_i} \frac{âˆ‚a^1_i}{âˆ‚w^{32}_ k} = 2(a^0-y) h'(z^0) \sum_i w^{10}_ i \frac{âˆ‚a^1_i}{âˆ‚w^{32}_ k} = $

$\displaystyle =2(a^0-y) h'(z^0) \sum_i w^{10}_ i \frac{âˆ‚a^1_i}{âˆ‚z^1_i} \frac{âˆ‚z^1_i}{âˆ‚a^2_j} \frac{âˆ‚a^2_j}{âˆ‚w^{32}_ k}$,  where j is where $w^{32}_ k$ is projecting

$\displaystyle =2(a^0-y) h'(z^0) \left( \sum_i w^{10}_ i h'(z^1_i) \right) w^{21}_ j \frac{âˆ‚a^2_j}{âˆ‚w^{32}_ k} = $

$\displaystyle =Îµ^0 \left( \sum_i w^{10}_ i h'(z^1_i) \right) w^{21}_ j h'(z^2_j) a^3_k =  \sum_i Îµ^1_i w^{21}_ j h'(z^2_j) a^3_k = Îµ^2_j a^3_k$

And so on; we can now do it for all layers. What's important is that we essentially take each error, scale it by derivatives of each activation function at each activation level h'(z); then **multiply by the transposed matrix of weights**, and get error-effects of the previous layer. Backprop!

**A summary in pseudocode:**
```
# Forward:
x = input
for L in layers:
    z = wâˆ™x + b   # Each layer should remember its x and z
    x = h(z)
    
# Backwards:
e = -âˆ‡Loss
for L in reversed(layers):
    Îµ = h'(z) â¨€ e  # Remember errors for updates below
    e  = wáµ€âˆ™Îµ       # Propagate errors backwards
for L in layers:
    b += Îµ*Î±         
    w += (Îµâˆ™xáµ€)*Î±
```

Above, `âˆ™` stands for dot-product, `â¨€` for elementwise Hadamard product, h' for dh/dz, and Î± for learning rate. To make error calculations more sane, I split it into e and Îµ, with Îµ matching formulas above. The problem with Îµ is that it uses weights from next layer, but h'(z) from this layer, which puts it off-kilter with layer-by-layer loop. Most tutorials call this thing Î´ instead of Îµ. I also have 2 loops for backprop, which is of course not needed if we can get access to this layer's error and previous layer's error at the same time. You just cannot do it without remembering the errors, as to backprop error you need w, but to update w you need each layer's "right", or "out" error. 

Some potential problems can be immediately deduced from this story. If a certain w_ji=0, it kills the effect of all weights converging on element j. Moreover, if the value of z_j is such that it drives h'(z_j) to zero, it also kills the gradient (aka **vanishing gradients**). Say, for sigmoids it happens for very high or very small z; for ReLUs it happens for any z<0, and they can't recover (aka "Dead ReLUs"). And the other way around, in a deep network, gradients can grow arbitrarily large (**exploding gradients**).

**References**
* [Backprop calc by 3blue1brown](https://www.youtube.com/watch?v=tIeHLnjs5U8&list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi&index=4)
* [Description by Michael Nielsen](http://neuralnetworksanddeeplearning.com/chap2.html), with slightly unusual notation
* [Flexible backprop from scratch](https://blog.zhaytam.com/2018/08/15/implement-neural-network-backpropagation/) - to verify my pseudocode

# Loss functions
Obvious choice for continuous output: **Eucleadian distance** (aka **Mean Squared Error**, or **MSE**)

For classification: **Cross-Entropy Loss**. The ground-truth is one-hot encoded vector; the prediction is a vector of probabilities. Definition: H(p,q) = -âˆ‘ p_i âˆ™ lg(q_i) where p_i are probabilities of different classes in the training set, and q_i are probabilities predicted by the model.

Motivation: essentially, average log-likelihood. Assume that the predictions of the model follow a true correct distribution, with q_i encoding P(x_i). Then what it the probability of observing n_i cases of x_i? Assuming that test cases are independent, P = âˆP(each observation) = âˆq_i ^ n_i . If we lg it (to replace products with sums), we get the total log-likelihood: L = âˆ‘ n_i âˆ™ lg(q_i) . If you average it by dividing by the total number of test cases, and denote p_i = n_i / N, we get loss = âˆ‘ p_i âˆ™ lg(q_i) =-H(p,q) . And then you are trying to minimize this value by making the model make predictions q_i such as the observed values (from P) are "minimally strange". Feels Bayesian, huh?

SVMs use a special thing called **Hinge loss** (see chapter "Classification")

**Huber loss**: a compromise between MSE loss that is tolerant to small noise (behaves nicely around 0, as xÂ² â‰ª x for small x), but is super-sensitive to outliers, and linear loss that is the other way around. Essentially, just a parabola with arms that smoothly transition to linear at some point, and continue like that. Formula: L = 1/2âˆ™xÂ² for x<d, but (abs(x)-d/2)âˆ™d for x>d. ([wiki ref](https://en.wikipedia.org/wiki/Huber_loss))

References:
* [by Daniel Godoy](https://towardsdatascience.com/understanding-binary-cross-entropy-log-loss-a-visual-explanation-a3ac6025181a) - a visual explanation for a binary case. Good intuition for why -log(1-prediction) makes sense: if you were very certain, and got it wrong, that's a more important learning point compared to a case when you were pretty lukewarm about it to begin with.
* [Wiki for cross-entropy](https://en.wikipedia.org/wiki/Cross_entropy)
* [A list of losses supported by Keras](https://keras.io/losses/)

# Regularization
(see also: Ridge regression in [[04_Regression]])

**L2 regularization**: use a modified loss = Loss(Data|Model) + Î»âˆ‘Ï‰Â² where Ï‰ are model weights, and Î» is a hyperparameter known as **Regularization rate**. High values of Î» push {Ï‰} towards normal distribution, while low Î» make the distributin of {Ï‰} closer to uniform. Discourages sparseness of {Ï‰}, as having many small weights becomes better than having a few solid ones. So, in a way, L2 regularization is pro-democracy, and anti-parsimony. As Î» is increased, weights are pressed down asymptotically.

Alternative: **L1 regularization**, aka **Lasso** (least absolute shrinking). Loss = Loss(Data|Model) +  Î»âˆ‘abs(Ï‰) . Aggressive shrinkage of small Ï‰; encourages parsimony; discourages "leakage of features". As Î» is increased, weights, one by one, suddenly drop dead from something to zero.

**Elastic net**: some sort of combination of both, with two different Î». Flexible, nice.

# Hyperparameters

**Hyperparameters**: those somewhat arbitrary values that define the type of solution the model is looking for, and the process of descent. 

## Learning rate

**Goldilocks principle** - the best learning rate should "magically" put you in the minimum in a very few steps. Large learning rate leads to noisy oscillations after what looked like a convergence. It may even break everything after convergence (unstable).

## Batch size

**Mini-batch**: process >1 (usually 10-1000) points at a time. Somewhere in between fully stochastic descent (1 point at a time) and classic regression (all points every time).

What is the **optimal batch size**? The downside of small batches (in the extreme case - fully stochastic descent) is that it's low (as by definition it's not parallel). The benefit is that it makes a trajectory weirder that may help to avoid narrow minima (overfitting). _Is it true? Did I understand it right? I'm not sure._ On the other hand, with larger batch sizes, you can get a boost in speed. The net effect of batch size b per computation is actually a sqrt(b) increase in time (hurt), as you do b times more calculations, but everything converges sqrt(b) times faster. But it can be parallelized, so for reasonably small b, it leads to a net improvement. And another effect, for high b descent is very smooth, which may make the model trapped at sharp minima. Seems to be related to the idea of "temperature" for optimization.

Refs:
* [Alex Seewald at Quora](https://www.quora.com/Is-full-batch-gradient-descent-with-unlimited-computer-power-always-better-than-mini-batch-gradient-descent)

## Hyperparameter search

# Dropout
Huge breakthrough, discovered in 2012: resolves overfitting in deep networks. Randomly inactivate a large share (~50%?) of all units in every layer at every training step; then only consider the output of remaining units; and only train them. When all weights are learned together, many of them slack out by just running to the ground (zero), and not contributing to anything (would have to be pruned). But with drop-out, we have something of a built-in ensemble method when many sub-networks have to train in parallel.

> Is this intuition even true? Is dropout in any way similar to ensemble? Are ensambles and regularization secretly the same thing?

A gradient of a dropped-out network is the same as for a full network, but with an additional "regularization term" for activation: âˆ‚J_dropped/âˆ‚w = âˆ‚J/dw + p(1-p)wâˆ™IÂ² , where p is the probability of elements staying active at each step (they use fixed probability, and not a fixed number of active elements). _Ref 1 pretends to have math, but immediately plunges from obvious to confusing._

Because of that, dropout is most effective for p=0.5 (it maximizes p(1-p)). In practice, it's OK to set p at 0.5 for intermediate layers, but it should be higher (0.8?) for input layers, in order not to imitate undersampling. Keras takes 1-p as an argument (p of dropping), so adjust accordingly.

**Gaussian dropout**: instead of completely eliminating a node at each step, just multiply each activation by ð’©(1,Ïƒ). A cool thing is that it doesn't change the gradient on average, so nothing needs to be scaled. (_What does it mean?_)

> How much exactly does drop-out help? How to quantify that? How do people quantify effectiveness of things like regularization? If dropout is similar to regularization, is it strictly better than regularization, or is it the same? If we explicitly add this wI^2-proportional (but fixed) regularization, will it give the same result? I'm guessing the answer is "no", but why?

There's a claim that dropout should not be used on convolutional networks, because it does not actually work (does not inactivate elements), as convolution introduces coordination between changes in different weights. Refs [1](https://towardsdatascience.com/dropout-on-convolutional-layers-is-weird-5c6ab14f19b2), [2](https://www.kdnuggets.com/2018/09/dropout-convolutional-networks.html)

Refs:
* [Simplified math](https://towardsdatascience.com/simplified-math-behind-dropout-in-deep-learning-6d50f3f47275), by Chitta Ranjan - *soso*

# Activation functions
* https://en.wikipedia.org/wiki/Gated_recurrent_unit

# Fancy layer types

## Pooling layers
**Maxpool**: Only retains the maximal value, and drops all the rest. Mostly used in convolutional networks, in which case it has dimensions, depth, and a stride. Has no learnable parameters. At backpropagation step, it only propagates to those neurons that contributed to the selected value (max value); all other neurons aren't updated. Good for downsampling feature maps, where the presence of a feature (quantified by different components of the depth-vector) is more important than the precise position of this feature.

Extreme version of this: **Global pooling** - entire tensor in one vector (equivalent to doing maxpooling with W and H of full image). A faster alternative to having a fully connected layer from a convolutional layer to a global feature vector.

**Average pooling**: as clear from the name, just averages all the inputs. Good for downsampling.

Refs: [one](https://machinelearningmastery.com/pooling-layers-for-convolutional-neural-networks/)

## Softmax
Takes in an aribtrary vector, and transforms it so that all values are positive, between 0 and 1, and the sum is = 1 (and so outputs can be interpreted as probabilities). Formula: first exp(each input), then divide by the sum of all. Preferred last layer in classification networks (in which case it's used with cross-entropy loss function).

If placed in the middle it is roughly equivalent to an exponential activation layer with batch normalization. But apparently it is possible to use it in the middle as well ([link example](https://github.com/gorobei9/jtest/blob/master/machine-learning/MNIST%20for%20Crazy%20People.ipynb)).

How to train Softmax layers? Better to balance labels, to use all possible training points for the label that is trained, but only a random subsample for negative labels. _Is it to avoid overtraining on negative examples, as for any given label the majority of examples in a natural dataset will be negative?_

## Batch normalization layer

#todo

# CNNs
**Convolutional Neural Networks**

To read:
* http://cs231n.github.io/convolutional-networks/ - nice concise introduction to CNNs
* https://cs.nyu.edu/~fergus/papers/zeilerECCV2014.pdf - Visualizing and Understanding Convolutional Networks. 2014. Zeiler
* Everything convolution: https://towardsdatascience.com/a-comprehensive-introduction-to-different-types-of-convolutions-in-deep-learning-669281e58215
* Wavenet: https://deepmind.com/blog/article/wavenet-generative-model-raw-audio
